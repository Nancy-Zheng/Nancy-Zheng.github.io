<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shengnan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录学习过程遇到的坑，方便自己回顾解决方法和为他人提供解决方法参考。">
<meta property="og:type" content="website">
<meta property="og:title" content="Shengnan&#39;s Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Shengnan&#39;s Blog">
<meta property="og:description" content="记录学习过程遇到的坑，方便自己回顾解决方法和为他人提供解决方法参考。">
<meta property="og:locale" content="zh">
<meta property="article:author" content="Shengnan Zheng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shengnan&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shengnan&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人学习博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-review-javascript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/review-javascript/" class="article-date">
  <time datetime="2019-07-25T03:12:41.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/review-javascript/">重学JS-《标准内置对象》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="区分全局对象和全局的对象"><a href="#区分全局对象和全局的对象" class="headerlink" title="区分全局对象和全局的对象"></a>区分全局对象和全局的对象</h2><p><strong>全局对象</strong>：（global object），是可以在全局作用域内，通过 this 访问（注意：严格模式下得到的是 undefined）<br><strong>全局的对象</strong>：（global objects）又叫标准内置对象，是全局作用域里的对象。<br>全局的对象包含全局对象和其他对象。</p>
<h2 id="标准内置对象分类"><a href="#标准内置对象分类" class="headerlink" title="标准内置对象分类"></a>标准内置对象分类</h2><h4 id="值属性"><a href="#值属性" class="headerlink" title="值属性"></a>值属性</h4><p>这些全局属性返回一个简单值，这些值<strong>没有自己的属性和方法</strong>。</p>
<ul>
<li>Infinity</li>
<li>NaN</li>
<li>undefined</li>
<li>null</li>
<li>globalThis</li>
</ul>
<h4 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h4><p><strong>全局函数可以直接调用，不需要在调用时指定所属对象</strong>，执行结束后会将结果直接返回给调用者。</p>
<ul>
<li>eval()</li>
<li>uneval()</li>
<li>isFinite()</li>
<li>isNaN()</li>
<li>parseFloat()</li>
<li>parseInt()</li>
<li>decodeURI()</li>
<li>decodeURIComponent()</li>
<li>encodeURI()</li>
<li>encodeURIComponent()</li>
<li>escape()</li>
<li>unescape()</li>
</ul>
<h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><p>基本对象是定义或使用其他对象的基础。基本对象包括<strong>一般对象</strong>、<strong>函数对象</strong>和<strong>错误对象</strong>。</p>
<ul>
<li><strong>Object</strong></li>
<li><strong>Function</strong></li>
<li><strong>Boolean</strong></li>
<li><strong>Symbol</strong></li>
<li><strong>Error</strong></li>
<li><strong>EvalError</strong></li>
<li><strong>InternalError</strong></li>
<li><strong>RangeError</strong></li>
<li><strong>ReferenceError</strong></li>
<li><strong>SyntaxError</strong></li>
<li><strong>TypeError</strong></li>
<li><strong>URIError</strong></li>
</ul>
<h4 id="数字和日期对象"><a href="#数字和日期对象" class="headerlink" title="数字和日期对象"></a>数字和日期对象</h4><p>用来表示数字、日期和执行数学计算的对象。</p>
<ul>
<li><strong>Number</strong></li>
<li>BigInt</li>
<li><strong>Math</strong></li>
<li><strong>Date</strong></li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>用来表示和操作字符串的对象。</p>
<ul>
<li><strong>String</strong></li>
<li><strong>RegExp</strong></li>
</ul>
<h4 id="可索引的集合对象"><a href="#可索引的集合对象" class="headerlink" title="可索引的集合对象"></a>可索引的集合对象</h4><p>这些对象表示按照索引值来排序的数据集合，包括<strong>数组</strong>和<strong>类型数组</strong>，以及<strong>类数组结构的对象</strong>。</p>
<ul>
<li><strong>Array</strong></li>
<li>Int8Array</li>
<li>Unit8Array</li>
<li>Unit8ClampedArray</li>
<li>Int16Array</li>
<li>Uint16Array</li>
<li>Int32Array</li>
<li>Uint32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
<li>BigInt64Array</li>
<li>BigUint64Array</li>
</ul>
<h4 id="使用键的集合对象"><a href="#使用键的集合对象" class="headerlink" title="使用键的集合对象"></a>使用键的集合对象</h4><p>这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</p>
<ul>
<li><strong>Map</strong></li>
<li><strong>Set</strong></li>
<li><strong>WeakMap</strong></li>
<li><strong>WeakSet</strong></li>
</ul>
<h4 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h4><p>这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON （JavaScript Object Notation）编码的数据。</p>
<ul>
<li>ArrayBuffer</li>
<li>SharedArrayBuffer</li>
<li>Atomics</li>
<li>DataView</li>
<li><strong>JSON</strong></li>
</ul>
<h4 id="控制抽象对象"><a href="#控制抽象对象" class="headerlink" title="控制抽象对象"></a>控制抽象对象</h4><ul>
<li><strong>Promise</strong></li>
<li><strong>Generator</strong></li>
<li>GeneratorFunctions</li>
<li>AsyncFunction</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li><strong>Reflext</strong></li>
<li><strong>Proxy</strong></li>
</ul>
<h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4><p>为了支持多语言处理而加入 ECMAScript 的对象。</p>
<ul>
<li>Intl</li>
<li>Intl.Collator</li>
<li>Intl.DateTimeFormat</li>
<li>Intl.ListFormat</li>
<li>Intl.NumberFormat</li>
<li>Intl.PluralRules</li>
<li>Intl.RelativeTimeFormat</li>
<li>Intl.Locale</li>
</ul>
<h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><ul>
<li>WebAssembly</li>
<li>WebAssembly.Module</li>
<li>WebAssembly.Instance</li>
<li>WebAssembly.Memory</li>
<li>WebAssembly.Table</li>
<li>WebAssembly.CompileError</li>
<li>WebAssembly.LinkError</li>
<li>WebAssembly.RuntimeError</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><strong>arguments</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/review-javascript/" data-id="ck43oz3h7000ny0g21ocn3bs6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/TypeScript/" class="article-date">
  <time datetime="2019-07-23T10:01:50.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/TypeScript/">TypeScript----(基础数据类型)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">关键字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">任意类型</td>
<td align="left">any</td>
<td align="left">声明为 any 的变量可以赋予任意类型的值</td>
</tr>
<tr>
<td align="left">数字类型</td>
<td align="left">number</td>
<td align="left">双精度 64 位浮点值。它可以用来表示整数和分数</td>
</tr>
</tbody></table>
<h2 id="任意类型-any-声明为-any-的变量可以赋予任意类型的值。"><a href="#任意类型-any-声明为-any-的变量可以赋予任意类型的值。" class="headerlink" title="任意类型 any 声明为 any 的变量可以赋予任意类型的值。"></a>任意类型 any 声明为 any 的变量可以赋予任意类型的值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1: any = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="keyword">let</span> arr2: any = <span class="string">'12'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="keyword">let</span> arr3: any = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="keyword">let</span> arr4: any = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br></pre></td></tr></table></figure>

<h2 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型 number"></a>数字类型 number</h2><p>双精度 64 位浮点值。它可以用来表示整数和分数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>; <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型 string"></a>字符串类型 string</h2><p>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1: string = <span class="string">'Runoob'</span>;</span><br><span class="line"><span class="keyword">let</span> years: number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> words: string = <span class="string">`您好，今年是 <span class="subst">$&#123;name1&#125;</span> 发布 <span class="subst">$&#123;years + <span class="number">1</span>&#125;</span> 周年`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(words);</span><br></pre></td></tr></table></figure>

<h2 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型 boolean"></a>布尔类型 boolean</h2><p>表示逻辑值：true 和 false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag: boolean = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数组类型-无"><a href="#数组类型-无" class="headerlink" title="数组类型 无"></a>数组类型 无</h2><p>声明变量为数组。</p>
<h4 id="在元素类型后面加上"><a href="#在元素类型后面加上" class="headerlink" title="在元素类型后面加上[]"></a>在元素类型后面加上[]</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: number[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr5: string[] = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">let</span> arr6: boolean[] = [<span class="literal">true</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure>

<h4 id="或者使用数组泛型，Array-lt-元素类型-gt"><a href="#或者使用数组泛型，Array-lt-元素类型-gt" class="headerlink" title="或者使用数组泛型，Array&lt;元素类型&gt;"></a>或者使用数组泛型，Array&lt;元素类型&gt;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr8: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">let</span> arr9: <span class="built_in">Array</span>&lt;boolean&gt; = [<span class="literal">true</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure>

<h2 id="元组-Tuple-无"><a href="#元组-Tuple-无" class="headerlink" title="元组(Tuple) 无"></a>元组(Tuple) 无</h2><p>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">1</span>]; <span class="comment">// 运行正常</span></span><br><span class="line"><span class="comment">// x = [1, 'hello']; // 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>]); <span class="comment">// 输出 hello</span></span><br><span class="line"><span class="comment">// 当访问一个已知索引的元素，会得到正确的类型：</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br><span class="line"><span class="comment">// 当访问一个越界的元素，会使用联合类型替代：</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h2><p>枚举类型用于定义数值集合。使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">Red,</span><br><span class="line">Green,</span><br><span class="line">Blue,</span><br><span class="line">Yellow,</span><br><span class="line">Black</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Blue;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</span></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，全部都采用手动赋值：</span></span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</span></span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: string = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName);  <span class="comment">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<p>// 编译后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Color;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Color</span>) </span>&#123;</span><br><span class="line">  Color[(Color[<span class="string">'Red'</span>] = <span class="number">0</span>)] = <span class="string">'Red'</span>;</span><br><span class="line">  Color[(Color[<span class="string">'Green'</span>] = <span class="number">1</span>)] = <span class="string">'Green'</span>;</span><br><span class="line">  Color[(Color[<span class="string">'Blue'</span>] = <span class="number">2</span>)] = <span class="string">'Blue'</span>;</span><br><span class="line">  Color[(Color[<span class="string">'Yellow'</span>] = <span class="number">3</span>)] = <span class="string">'Yellow'</span>;</span><br><span class="line">  Color[(Color[<span class="string">'Black'</span>] = <span class="number">4</span>)] = <span class="string">'Black'</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> c = Color.Blue;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<h2 id="void-void"><a href="#void-void" class="headerlink" title="void void"></a>void void</h2><p>用于标识方法返回值的类型，表示该方法没有返回值。<br>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hello Runoob'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h2 id="null-null"><a href="#null-null" class="headerlink" title="null null"></a>null null</h2><p>表示对象值缺失。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="undefined-undefined"><a href="#undefined-undefined" class="headerlink" title="undefined undefined"></a>undefined undefined</h2><p>用于初始化变量为一个未定义的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下 <strong>null 和 undefined 是所有类型的子类型</strong>。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>
<h2 id="never-never"><a href="#never-never" class="headerlink" title="never never"></a>never never</h2><p><strong>never 是其它类型（包括 null 和 undefined）的子类型</strong>，代表从不会出现的值。<br>never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p>
<p><strong>never 类型是任何类型的子类型，也可以赋值给任何类型</strong>；然而，<strong>没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">'Something failed'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p>
<p>使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="string">'string'</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">false</span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">undefined</span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 <strong>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构</strong>。 <strong>它没有运行时的影响，只是在编译阶段起作用</strong>。 TypeScript 会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。</p>
<h4 id="1-“尖括号”语法"><a href="#1-“尖括号”语法" class="headerlink" title="1.“尖括号”语法"></a>1.“尖括号”语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-as-语法"><a href="#2-as-语法" class="headerlink" title="2.as 语法"></a>2.as 语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure>

<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，<strong>当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/TypeScript/" data-id="ck43oz3gx0005y0g2a7wv3b4x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前后端分离" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" class="article-date">
  <time datetime="2019-07-23T04:26:58.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/">前后端分离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前后端分离的应用场景"><a href="#前后端分离的应用场景" class="headerlink" title="前后端分离的应用场景"></a>前后端分离的应用场景</h2><ul>
<li>前端页面静态化（Page Static）</li>
<li>前端页面服务化（PAAS,Page as Service）</li>
<li>服务端渲染（SSR,Server Side Render）</li>
<li>渐进式 Web 应用（PWA,Progressive Web App）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" data-id="ck43oz3hr000vy0g2e0880q1q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RESTful" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/RESTful/" class="article-date">
  <time datetime="2019-07-22T05:33:01.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/RESTful/">了解RESTful</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>RESTful(REpresentational State Transfer,表现层状态转化)</p>
<h4 id="资源的表现层"><a href="#资源的表现层" class="headerlink" title="资源的表现层"></a>资源的表现层</h4><ul>
<li><p>资源<br>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。</p>
</li>
<li><p>表现层<br>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。</p>
</li>
</ul>
<h4 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h4><p>访问一个网站，就代表了<strong>客户端和服务器的一个互动过程</strong>。在这个过程中，势必涉及到<strong>数据和状态的变化</strong>。互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：<strong>GET</strong>、<strong>POST</strong>、<strong>PUT</strong>、<strong>DELETE</strong>。它们分别对应四种基本操作：<strong>GET 用来获取资源</strong>，<strong>POST 用来新建资源（也可以用于更新资源）</strong>，<strong>PUT 用来更新资源</strong>，<strong>DELETE 用来删除资源</strong>。</p>
<h2 id="总结-RESTful-架构："><a href="#总结-RESTful-架构：" class="headerlink" title="总结 RESTful 架构："></a>总结 RESTful 架构：</h2><ul>
<li><p>（1）每一个 URI 代表一种资源；</p>
</li>
<li><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
</li>
<li><p>（3）客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
</li>
</ul>
<h2 id="常见设计错误"><a href="#常见设计错误" class="headerlink" title="常见设计错误"></a>常见设计错误</h2><ul>
<li>1.URI 包含动词<br>因为”资源”表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。</li>
<li>2.URI 加入版本号<br>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version&#x3D;1.0</span><br><span class="line"></span><br><span class="line">　Accept: vnd.example-com.foo+json; version&#x3D;1.1</span><br><span class="line"></span><br><span class="line">　Accept: vnd.example-com.foo+json; version&#x3D;2.0</span><br></pre></td></tr></table></figure>

<h2 id="RESTful-最佳实践"><a href="#RESTful-最佳实践" class="headerlink" title="RESTful 最佳实践"></a>RESTful 最佳实践</h2><h4 id="URI-设计"><a href="#URI-设计" class="headerlink" title="URI 设计"></a>URI 设计</h4><ul>
<li><p>动词+宾语<br>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构</p>
<p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET：读取（Read）</span><br><span class="line">POST：新建（Create）</span><br><span class="line">PUT：更新（Update）</span><br><span class="line">PATCH：更新（Update），通常是部分更新</span><br><span class="line">DELETE：删除（Delete）</span><br></pre></td></tr></table></figure>
</li>
<li><p>动词的覆盖<br>有些客户端只能使用 GET 和 POST 这两种方法。服务器必须接受 POST 模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上 <strong>X-HTTP-Method-Override</strong> 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/<span class="number">4</span> HTTP/<span class="number">1.1</span></span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure>

<p>上面代码中，X-HTTP-Method-Override 指定本次请求的方法是 PUT，而不是 POST。</p>
</li>
<li><p>宾语必须是名词<br>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。<br>比如，/articles 这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;getAllCars</span><br><span class="line">&#x2F;createNewCar</span><br><span class="line">&#x2F;deleteAllRedCars</span><br></pre></td></tr></table></figure></li>
<li><p>复数 URL<br>既然 URL 是名词，那么应该使用复数，还是单数？这没有统一的规定，但是常见的操作是读取一个集合，比如 GET /articles（读取所有文章），这里明显应该是复数。<br>为了统一起见，建议都使用复数 URL，比如 GET /articles/2 要好于 GET /article/2。</p>
</li>
<li><p>避免多级 URL<br>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;authors&#x2F;12&#x2F;categories&#x2F;2</span><br></pre></td></tr></table></figure>
<p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。<br>更好的做法是，<strong>除了第一级，其他级别都用查询字符串表达</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/<span class="number">12</span>?categories=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;articles&#x2F;published</span><br></pre></td></tr></table></figure>
<p><strong>查询字符串</strong>的写法明显更好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles?published=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li><p>状态码必须精确<br>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure>

<p>每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码</p>
</li>
</ul>
<h6 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h6><p>API 不需要 1xx 状态码</p>
<h6 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h6><p>200 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET: <span class="number">200</span> OK</span><br><span class="line">POST: <span class="number">201</span> Created</span><br><span class="line">PUT: <span class="number">200</span> OK</span><br><span class="line">PATCH: <span class="number">200</span> OK</span><br><span class="line">DELETE: <span class="number">204</span> No Content</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> OK 成功</span><br><span class="line"><span class="number">201</span> Created 表示生成了新的资源</span><br><span class="line"><span class="number">202</span> Accepted 状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理</span><br><span class="line"><span class="number">204</span> No Content 表示资源已经不存在</span><br></pre></td></tr></table></figure>

<p>上面代码中，POST 返回 201 状态码，表示生成了新的资源；DELETE 返回 204 状态码，表示资源已经不存在。</p>
<p>此外，202 Accepted 状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"task"</span>: &#123;</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"/api/company/job-management/jobs/2130040"</span>,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"2130040"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">301</span> Moved Permanently 永久重定向</span><br><span class="line"><span class="number">302</span> Found 暂时重定向，<span class="number">307</span> 也是这个含义</span><br><span class="line"><span class="number">303</span> See Other 表示参考另一个 URL</span><br><span class="line"><span class="number">307</span> Temporary Redirect 临时重定向</span><br></pre></td></tr></table></figure>

<p>API 用不到 301 状态码（永久重定向）和 302 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p>
<p>API 用到的 3xx 状态码，主要是 303 See Other，表示参考另一个 URL。它与 302 和 307 的含义一样，也是”暂时重定向”，区别在于 <strong>302 和 307 用于 GET 请求</strong>，而 <strong>303 用于 POST、PUT 和 DELETE 请求</strong>。收到 303 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">303</span> See Other</span><br><span class="line">Location: <span class="regexp">/api/</span>orders/<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h6 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h6><p>4xx 状态码表示客户端错误，主要有下面几种。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">400</span> Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><span class="line"></span><br><span class="line"><span class="number">401</span> Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><span class="line"></span><br><span class="line"><span class="number">403</span> Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><span class="line"></span><br><span class="line"><span class="number">404</span> Not Found：所请求的资源不存在，或不可用。</span><br><span class="line"></span><br><span class="line"><span class="number">405</span> Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><span class="line"></span><br><span class="line"><span class="number">410</span> Gone：所请求的资源已从这个地址转移，不再可用。</span><br><span class="line"></span><br><span class="line"><span class="number">415</span> Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 <span class="built_in">JSON</span> 格式，但是客户端要求返回 XML 格式。</span><br><span class="line"></span><br><span class="line"><span class="number">422</span> Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><span class="line"></span><br><span class="line"><span class="number">429</span> Too Many Requests：客户端的请求次数超过限额。</span><br></pre></td></tr></table></figure>

<h6 id="5XX-状态码"><a href="#5XX-状态码" class="headerlink" title="5XX 状态码"></a>5XX 状态码</h6><p>5xx 状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span>：客户端请求有效，服务器处理时发生了意外。</span><br><span class="line"></span><br><span class="line"><span class="number">503</span> Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span><br></pre></td></tr></table></figure>

<h4 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h4><h6 id="不要返回纯文本"><a href="#不要返回纯文本" class="headerlink" title="不要返回纯文本"></a>不要返回纯文本</h6><p>API 返回的数据格式，不应该是纯文本，而应该是一个 <strong>JSON 对象</strong>，因为这样才能返回标准的结构化数据。所以，<strong>服务器回应的 HTTP 头的 Content-Type</strong>属性要设为<strong>application/json</strong>。<br><strong>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式</strong>，即请求的 HTTP 头的 <strong>ACCEPT</strong> 属性也要设成 <strong>application/json</strong>。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/<span class="number">2</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<h6 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h6><p>有一种不恰当的做法是，即使发生错误，也返回 200 状态码，把错误信息放在数据体里面，就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回</strong>。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"error"</span>: <span class="string">"Invalid payoad."</span>,</span><br><span class="line">  <span class="string">"detail"</span>: &#123;</span><br><span class="line">     <span class="string">"surname"</span>: <span class="string">"This field is required."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h6><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 <strong>HATEOAS</strong>。</p>
<p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"feeds_url"</span>: <span class="string">"https://api.github.com/feeds"</span>,</span><br><span class="line">  <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/user/followers"</span>,</span><br><span class="line">  <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/user/following&#123;/target&#125;"</span>,</span><br><span class="line">  <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="string">"hub_url"</span>: <span class="string">"https://api.github.com/hub"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"In progress"</span>,</span><br><span class="line">   <span class="string">"links"</span>: &#123;[</span><br><span class="line">    &#123; <span class="string">"rel"</span>:<span class="string">"cancel"</span>, <span class="string">"method"</span>: <span class="string">"delete"</span>, <span class="string">"href"</span>:<span class="string">"/api/status/12345"</span> &#125; ,</span><br><span class="line">    &#123; <span class="string">"rel"</span>:<span class="string">"edit"</span>, <span class="string">"method"</span>: <span class="string">"put"</span>, <span class="string">"href"</span>:<span class="string">"/api/status/12345"</span> &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">阮一峰 restful</a><br><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">阮一峰 restful 最佳实践</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/RESTful/" data-id="ck43oz3id001jy0g287anhhz3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Object-definProperty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/Object-definProperty/" class="article-date">
  <time datetime="2019-07-16T09:46:28.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/Object-definProperty/">Object.definProperty()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Object-defineProperty-方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。"><a href="#Object-defineProperty-方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。" class="headerlink" title="Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。"></a>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>obj（对象）<br>The object on which to define the property.<br>要在其上定义属性的对象</p>
</li>
<li><p>prop(属性或者 symbol 的名称)<br>The name or Symbol of the property to be defined or modified.<br>要定义或修改的属性的名称</p>
</li>
<li><p>descriptor(属性描述符)<br>The descriptor for the property being defined or modified.<br>将被定义或修改的属性描述符</p>
</li>
<li><p>返回值<br>被传递给函数的对象</p>
<p>在 ES6 中，由于 Symbol 类型的特殊性，用 Symbol 类型的值来做对象的 key 与常规的定义或修改不同，而 Object.defineProperty 是定义 key 为 Symbol 的属性的方法之一。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">  value: <span class="number">42</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object2, <span class="string">'property2'</span>, &#123;</span><br><span class="line">  value: <span class="number">42</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">object1.property2 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"><span class="built_in">console</span>.log(object1.property2); <span class="comment">// 77</span></span><br></pre></td></tr></table></figure>

<p>该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for…in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。<strong>默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。</strong></p>
<h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>对象目前有两种属性描述符：</p>
<p><strong>描述符必须是这两种形式之一；不能同时是两者。</strong></p>
<ul>
<li>数据描述符</li>
</ul>
<p>是一个具有值的属性，该值可能是可写，也可以是不可写的</p>
<ul>
<li>存取描述符</li>
</ul>
<p>是由 getter-setter 函数对描述的属性</p>
<h4 id="两者均有"><a href="#两者均有" class="headerlink" title="两者均有"></a>两者均有</h4><h5 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h5><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 <strong>false</strong>。<br><strong>configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// throws a TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123; <span class="attr">configurable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// throws a TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// throws a TypeError (set was undefined previously)</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123; <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; &#125;);</span><br><span class="line"><span class="comment">// throws a TypeError (even though the new get does exactly the same thing)</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// throws a TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123; <span class="attr">value</span>: <span class="number">12</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 1</span></span><br><span class="line"><span class="keyword">delete</span> o.a; <span class="comment">// Nothing happens</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure>

<h5 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h5><p>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 <strong>false</strong>。</p>
<p><strong>enumerable 定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'b'</span>, &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'c'</span>, &#123; <span class="attr">value</span>: <span class="number">3</span> &#125;); <span class="comment">// enumerable defaults to false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 'a' 和 'd' (in undefined order)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// ["a", "d"]</span></span><br><span class="line"></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'a'</span>); <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'b'</span>); <span class="comment">// false</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'c'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="数据描述符（有）"><a href="#数据描述符（有）" class="headerlink" title="数据描述符（有）"></a>数据描述符（有）</h4><h5 id="value"><a href="#value" class="headerlink" title="value"></a>value</h5><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 <strong>undefined</strong>。</p>
<h5 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h5><p>当且仅当该属性的 writable 为 true 时，value 才能被<u>赋值运算符</u>改变。默认为 <strong>false</strong>。<br><strong>当 writable 属性设置为 false 时，该属性被称为“不可写”。它不能被重新分配。</strong><br><strong>严格模式下修改了 writable 为 false 的属性会报错</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// Creates a new object</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 37</span></span><br><span class="line">o.a = <span class="number">25</span>; <span class="comment">// No error thrown</span></span><br><span class="line"><span class="comment">// (it would throw in strict mode,</span></span><br><span class="line"><span class="comment">// even if the value had been the same)</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 37. The assignment didn't work.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strict mode</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o, <span class="string">'b'</span>, &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">  o.b = <span class="number">3</span>; <span class="comment">// throws TypeError: "b" is read-only</span></span><br><span class="line">  <span class="keyword">return</span> o.b; <span class="comment">// returns 2 without the line above</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="存取描述符（有）"><a href="#存取描述符（有）" class="headerlink" title="存取描述符（有）"></a>存取描述符（有）</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入 this 对象（由于继承关系，这里的 this 并不一定是定义该属性的对象）。<br>默认为 <strong>undefined</strong>。</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<br>默认为 <strong>undefined</strong>。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">configurable</th>
<th align="left">enumerable</th>
<th align="left">value</th>
<th align="left">writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存取描述符</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p><strong>如果一个描述符不具有 value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value 或 writable)和(get 或 set)关键字，将会产生一个异常。</strong></p>
<h2 id="创建属性"><a href="#创建属性" class="headerlink" title="创建属性"></a>创建属性</h2><p>如果对象中不存在，这个即将要创建的属性，Object.defineProperty()就创建该属性，<br>当描述符中省略某些字段时，这些字段将使用他们的默认值。configurable,enumerable,writable 三者默认值均为<strong>false</strong>，value、get、set 三者默认值均为<strong>undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据描述符和存取描述符不能混合使用</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'conflict'</span>, &#123;</span><br><span class="line">  value: <span class="number">0x9f91102</span>,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xdeadbeef</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在对象中添加一个属性与存取描述符的示例</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'b'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    a = newVal;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  <span class="comment">//   value: 19</span></span><br><span class="line">  <span class="comment">//   TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute</span></span><br><span class="line">  <span class="comment">//   value是数据属性，get、set是存取属性，两者不可共存</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">38</span>;</span><br><span class="line"><span class="comment">// 对象o拥有了属性b，值为38</span></span><br><span class="line"><span class="comment">// o.b的值现在总是与a相同，除非重新定义o.b</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a); <span class="comment">// a 38</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>, obj.b); <span class="comment">// b 38</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">39</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a); <span class="comment">// a 39</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>, obj.b); <span class="comment">// b 39</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与数据描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象o拥有了属性a，值为37</span></span><br></pre></td></tr></table></figure>

<h2 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h2><p>如果这个对象中存在该属性，那么 Object.defineProperty()将尝试根据描述符的值以及对象当前的配置来修改这个属性。如果该对象之前的<strong>configurable 值为 false</strong>，那么该属性是不可配置的，并没有属性可被改变（除了单向改变 writable 为 false），当属性不可配置时，不能在数据和访问器属性类型之间切换。<br>当试图改变不可配置属性（除了 value 和 writable 属性之外）的值时会抛出 TypeError，除非当前值和新值相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">18</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">19</span> <span class="comment">// TypeError: Cannot redefine property: a</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span> <span class="comment">// TypeError: Cannot redefine property: a</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span> <span class="comment">// TypeError: Cannot redefine property: a</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span> <span class="comment">// 不会报错</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span> <span class="comment">// TypeError: Cannot redefine property: a</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span> <span class="comment">// 不会报错</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="注意：通常，使用点运算符和-Object-defineProperty-为对象的属性赋值时，数据描述符中的属性默认值是不同的"><a href="#注意：通常，使用点运算符和-Object-defineProperty-为对象的属性赋值时，数据描述符中的属性默认值是不同的" class="headerlink" title="注意：通常，使用点运算符和 Object.defineProperty()为对象的属性赋值时，数据描述符中的属性默认值是不同的"></a>注意：通常，使用点运算符和 Object.defineProperty()为对象的属性赋值时，数据描述符中的属性默认值是不同的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">  <span class="comment">// configurable,enumerable,writable 如果没有显示声明，三者的默认值均为 false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/Object-definProperty/" data-id="ck43oz3ib001iy0g2g3uo58q8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object/" rel="tag">Object</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-localStorage如何存储对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/localStorage%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2019-07-16T07:10:52.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/localStorage%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/">localStorage如何存储对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSON 对象提供的 parse 和 stringify 将其他数据类型转化成字符串，再存储到 storage 中就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="string">"name:"</span>nancy<span class="string">",age:18&#125;</span></span><br><span class="line"><span class="string">// 存</span></span><br><span class="line"><span class="string">localStorage.setItem("</span>userInfo<span class="string">",JSON.stringify(obj))</span></span><br><span class="line"><span class="string">// 取</span></span><br><span class="line"><span class="string">var user = JSON.parse(localStorage.getItem("</span>userInfo<span class="string">"))</span></span><br><span class="line"><span class="string">// 删除</span></span><br><span class="line"><span class="string">localStorage.removeItem("</span>userInfo<span class="string">")</span></span><br><span class="line"><span class="string">// 清除</span></span><br><span class="line"><span class="string">localStorage.clear()</span></span><br></pre></td></tr></table></figure>

<h4 id="localStorage-中的键值对总是以字符串的形式存储"><a href="#localStorage-中的键值对总是以字符串的形式存储" class="headerlink" title="localStorage 中的键值对总是以字符串的形式存储"></a>localStorage 中的键值对总是以字符串的形式存储</h4><p>需要注意, 和 js 对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/localStorage%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/" data-id="ck43oz3h5000jy0g2djj7aq11" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/localStorage/" rel="tag">localStorage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1/" rel="tag">对象</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Sets-and-Maps-ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/Sets-and-Maps-ES6/" class="article-date">
  <time datetime="2019-07-16T05:40:57.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/Sets-and-Maps-ES6/">Sets and Maps --- ES6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么需要-Set-和-Map？"><a href="#为什么需要-Set-和-Map？" class="headerlink" title="为什么需要 Set 和 Map？"></a>为什么需要 Set 和 Map？</h2><p>JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组（可能有人会质疑所有的非类数组对象都是键值对的集合，但其实它们的用途和数组有根本上的区别）。<u>数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用</u>。因为数组的索引只能是数字类型，<strong>当开发者觉得非数字类型的索引是必要的时候会使用非数组对象</strong>。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现</p>
<p>【原文：】JavaScript only had one type of collection, represented by the Array type, for most of its history (though some may argue all non-array objects are just collections of key-value pairs, their intended use was, originally quite different from arrays). Arrays are used in JavaScript just like arrays in other languages, but the lack of other collection options meant arrays were often used as queues and stacks, as well. Since arrays only use numeric indices, developers used non-array objects whenever a non-numeric index was necessary. That technique led to custom implementations of sets and maps using non-array objects.</p>
<h2 id="ES5-如何模拟-Set-和-Map？"><a href="#ES5-如何模拟-Set-和-Map？" class="headerlink" title="ES5 如何模拟 Set 和 Map？"></a>ES5 如何模拟 Set 和 Map？</h2><p>set 是非重复值的集合。你一般不会像在数组中那样来访问 set 中的某个值；相反，它常被用来检查某个值是否存在。map 则是包含键和对应值的集合，所以 map 中的每个元素都有两块数据，当指定键的时候对应的值会被读取。map 常用作缓存以便之后需要的时候能快速提取数据。虽然 ECMAScript 5 没有正式支持 set 和 map，开发者使用非类数组对象对它们进行了模拟。</p>
<p>【原文】A set is a list of values that cannot contain duplicates. You typically don’t access individual items in a set like you would items in an array; instead, it’s much more common to just check a set to see if a value is present. A map is a collection of keys that correspond to specific values. As such, each item in a map stores two pieces of data, and values are retrieved by specifying the key to read from. Maps are frequently used as caches, for storing data to be quickly retrieved later. While ECMAScript 5 didn’t formally have sets and maps, developers worked around this limitation using non-array objects, too.</p>
<p>在 ECMAScript 5 中，开发者使用对象属性来模拟 set 和 map</p>
<h5 id="set-常被用来检查某个值是否存在"><a href="#set-常被用来检查某个值是否存在" class="headerlink" title="set 常被用来检查某个值是否存在"></a>set 常被用来检查某个值是否存在</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Object.create(null);</span><br><span class="line"><span class="keyword">set</span>.foo = true;</span><br><span class="line">// 检查属性是否存在</span><br><span class="line">if (<span class="keyword">set</span>.foo) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中的 set 对象没有原型，确保它不会继承任何属性。在 ECMAScript 5 中使用对象属性来检查唯一值的用法十分普遍。当给 set 对象添加属性并设置值为 true 之后，条件判断语句（如本例中的 if 语句）可以轻松地检查某个值是否存在。</p>
<p><strong>使用对象模拟的 set 和 map 之间唯一真正的区别是键值的类型</strong></p>
<h5 id="map-大部分情况下被用来提取数据"><a href="#map-大部分情况下被用来提取数据" class="headerlink" title="map 大部分情况下被用来提取数据"></a>map 大部分情况下被用来提取数据</h5><p>map 则是包含键和对应值的集合，所以 map 中的每个元素都有两块数据，当指定键的时候对应的值会被读取。map 常用作缓存以便之后需要的时候能快速提取数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// 提取属性值</span></span><br><span class="line"><span class="keyword">let</span> value = map.foo;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<h4 id="使用对象模拟的问题（Problems-with-Workarounds）"><a href="#使用对象模拟的问题（Problems-with-Workarounds）" class="headerlink" title="使用对象模拟的问题（Problems with Workarounds）"></a>使用对象模拟的问题（Problems with Workarounds）</h4><p>虽然在简单的情况下使用对象模拟的 set 和 map 没有太大的问题，不过当条件变得复杂时对象属性的限制很快就会暴露出来。例如，既然对象属性的类型必须为字符串，你必须保证键存储的值是唯一的。考虑如下的代码：</p>
<h5 id="当键的值为数字类型的情况下也会有一些问题"><a href="#当键的值为数字类型的情况下也会有一些问题" class="headerlink" title="当键的值为数字类型的情况下也会有一些问题"></a>当键的值为数字类型的情况下也会有一些问题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map[<span class="number">5</span>] = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="string">'5'</span>]); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>在内部，<strong>数字类型的键会被转化为字符串</strong>，所以 map[“5”] 和 map[5] 引用了相同的属性。当你想同时使用数字和字符串类型的键时，该内部实现是制造问题的根源。同样，当使用对象作为键的时候也会出现麻烦</p>
<h5 id="当键的值为对象的情况下也会有一些问题"><a href="#当键的值为对象的情况下也会有一些问题" class="headerlink" title="当键的值为对象的情况下也会有一些问题"></a>当键的值为对象的情况下也会有一些问题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  key1 = &#123;&#125;,</span><br><span class="line">  key2 = &#123;&#125;;</span><br><span class="line">map[key1] = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(map[key2]); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>在这里，map[key2] 和 map[key1] 引用了相同的值。<strong>对象中的 key1 和 key2 被转化为字符串是”[object Object]”</strong>。开发者在一般的思维下都会自然认为不同的键名就代表不同的键，因此这里会造成难以察觉的错误。<br>默认的字符串转化使得对象很难被当作键来使用（该情况同样存在于 set）。</p>
<h5 id="当键的值为假值的情况下也会有一些问题"><a href="#当键的值为假值的情况下也会有一些问题" class="headerlink" title="当键的值为假值的情况下也会有一些问题"></a>当键的值为假值的情况下也会有一些问题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 检查 "count" 是否存在或该值是否为假？</span></span><br><span class="line"><span class="keyword">if</span> (map.count) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例中 map.count 的用法存在歧义。该语句的目的到底是检查 map.count 是否存在还是它的值是否为假。if 中的代码会执行是因为 1 被视为真值。然而 map.count 如果不存在或它的值为假则代码都不会被执行。</p>
<h2 id="ES5-模拟-set-和-map-存在的缺陷"><a href="#ES5-模拟-set-和-map-存在的缺陷" class="headerlink" title="ES5 模拟 set 和 map 存在的缺陷"></a>ES5 模拟 set 和 map 存在的缺陷</h2><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><pre><code>let map = Object.create（null）
    作用：用来提取数据
1.数字类型的键会被转化为字符串
    如：map[5] 等价于 map[&quot;5&quot;]
2.使用对象作为键会被转化为字符串 &quot;[object Object]&quot;
3.当键的值为假时，出现在if语句中，会有问题（无法区别到底是判断是否又该键值还是判断该键值的真假）</code></pre><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><pre><code>    let set = Object.create（null）
        作用：验证键是否存在
使用对象模拟的 set 和 map 之间唯一真正的区别是键值的类型</code></pre><p>JavaScript 有 in 操作符可以在不读取值的情况下检查某个属性是否在对象中存在，如果是的话则返回 true。不过，该操作符还会检查对象的原型，这就使得该操作只有在对象不存在原型的条件下才是可靠的。即使这样，很多开发者都使用了上例中不当的方式而没有使用 in 。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h5 id="新建-new"><a href="#新建-new" class="headerlink" title="新建 new"></a>新建 new</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set（）</span><br></pre></td></tr></table></figure>

<h5 id="添加-add"><a href="#添加-add" class="headerlink" title="添加 add"></a>添加 add</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>.add（5）</span><br><span class="line"><span class="keyword">set</span>.add（“5”）</span><br><span class="line">// 如果 add() 方法由同一个参数调用了多次，那么首次之后的调用将会被忽略：</span><br></pre></td></tr></table></figure>

<h5 id="大小-size"><a href="#大小-size" class="headerlink" title="大小 size"></a>大小 size</h5><pre><code>对象也不会转化为字符串</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> =new Set();</span><br><span class="line">let key1=&#123;&#125;；</span><br><span class="line"><span class="keyword">let</span> key2=&#123;&#125;;</span><br><span class="line"><span class="keyword">set</span>.add(key1)；</span><br><span class="line"><span class="keyword">set</span>.add(key2);</span><br><span class="line"><span class="keyword">set</span>.size // 2</span><br><span class="line">key1 和 key2 不会转换为字符串</span><br><span class="line"><span class="keyword">set</span>.size // 2 <span class="keyword">set</span> 在比较值是否相等的时候不做强制类型转换</span><br></pre></td></tr></table></figure>

<h5 id="是否存在某个值-has"><a href="#是否存在某个值-has" class="headerlink" title="是否存在某个值 has"></a>是否存在某个值 has</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>.has(5); // true</span><br><span class="line"><span class="keyword">set</span>.has('5'); //true</span><br></pre></td></tr></table></figure>

<h5 id="移除-delete"><a href="#移除-delete" class="headerlink" title="移除 delete"></a>移除 delete</h5><h5 id="清空-clear"><a href="#清空-clear" class="headerlink" title="清空 clear"></a>清空 clear</h5><h5 id="遍历-forEach"><a href="#遍历-forEach" class="headerlink" title="遍历 forEach"></a>遍历 forEach</h5><p>参数 1：下一位置的值<br>参数 2：和首个参数的值相同<br>参数 3：操作的 set 本身<br>set 实现的 forEach() 方法和数组存在的差异在于接收的前两个参数是相同的。<br>其它包含 forEach() 方法的对象（数组和 map）在该方法的回调函数中也会接收三个参数。前两个参数分别为下一位置的值和键（其中数组版本中的键为数字索引）。</p>
<p>但是 set 并不包含键。制定 ECMAScript 6 标准的相关人员本可以在 set 中设定 forEach() 的回调函数只接受两个参数。不过他们却另辟蹊径的找到了统一回调函数的办法：set 中的每一项既是键也是值。于是 set 为了和数组与 map 中的 forEach() 方法保持一致，将回调函数中的前两个参数设为相同。</p>
<p>除了参数个数的差异外，set 版本的 forEach() 和 数组基本相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach(function(value, key, ownerSet) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' '</span> + value);</span><br><span class="line">  <span class="built_in">console</span>.log(ownerSet === <span class="keyword">set</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出结果：</span><br><span class="line">// 1 1</span><br><span class="line">// true</span><br><span class="line">// 2 2</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<p>该段代码将数组中的每一项添加到 set 中然后将值传递给 forEach() 的回调函数。回调函数每一次执行时，key 和 value 都是相同的，同时 ownerSet 则等同于 set。<br>转化为数组 … 扩展运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set（[1,2,2,3,3,3,3,4,5,4,4]）</span><br><span class="line">let arr = [...<span class="keyword">set</span>]</span><br><span class="line"></span><br><span class="line">console.log(arr) // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h5 id="应用：数组去重"><a href="#应用：数组去重" class="headerlink" title="应用：数组去重"></a>应用：数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dupArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 在 eliminateDuplicates() 函数中，set 只是被当作临时的代理以便在创建新的数组之前过滤掉重复项。</span></span><br><span class="line"><span class="keyword">let</span> noDupArr = eliminateDuplicates(dupArr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'noDupArr'</span>, noDupArr); <span class="comment">// noDupArr [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="weak-Set"><a href="#weak-Set" class="headerlink" title="weak Set"></a>weak Set</h2><pre><code>为什么需要 weak set
    一个对象存储在 set 内部或存储于一个变量在效果上是等同的。只要对该 Set 实例的引用存在，那么存储的对象在垃圾回收以释放内存的时候无法被销毁，</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(),</span><br><span class="line">  key = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 1</span><br><span class="line"></span><br><span class="line">// 销毁引用</span><br><span class="line">key = null;</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 1</span><br></pre></td></tr></table></figure>

<p>// 重新获得了引用<br>key = […set][0];<br>将 key 设置为 null 只是清除了对 key 对象的一个引用，但是其它引用还存于 set 内部。你仍然可以使用扩展运算符将 set 转化为 数组后获取它。在大部分编程中这个结果是可以接受的，但某些时候，当其它引用解除之后 set 内部能自动解除相关引用是再好不过的<br>当在一个网页中使用 JavaScript 追踪一些可能在之后会被销毁 DOM 元素，你不希望有任何残留的 DOM 元素引用存在。（这种情况称其为内存泄漏）<br>为了减少这些情况的出现，ECMAScript 6 同时引入了 weak set 。该类型不允许存储原始值而专门存储弱对象引用。由于弱引用不会被当做剩余存在的引用，所以它不会阻止垃圾回收。</p>
<h2 id="☆-Set-和-Weak-Set-的区别？"><a href="#☆-Set-和-Weak-Set-的区别？" class="headerlink" title="☆ Set 和 Weak Set 的区别？"></a>☆ Set 和 Weak Set 的区别？</h2><h5 id="1-当调用-add-，has-或-delete-方法传入了一个非对象参数时，一个错误会被抛出。"><a href="#1-当调用-add-，has-或-delete-方法传入了一个非对象参数时，一个错误会被抛出。" class="headerlink" title="1.当调用 add()，has() 或 delete() 方法传入了一个非对象参数时，一个错误会被抛出。"></a>1.当调用 add()，has() 或 delete() 方法<strong>传入了一个非对象参数时，一个错误会被抛出</strong>。</h5><h5 id="2-weak-set-不是可迭代类型，因此不能被用在-for-of-循环中。"><a href="#2-weak-set-不是可迭代类型，因此不能被用在-for-of-循环中。" class="headerlink" title="2.weak set 不是可迭代类型，因此不能被用在 for-of 循环中。"></a>2.weak set 不是可迭代类型，因此<strong>不能被用在 for-of 循环中</strong>。</h5><h5 id="3-weak-set-无法暴露出自身的迭代器（例如-keys-和-values-方法），所以没有任何编程手段来确定-weak-set-中的内容"><a href="#3-weak-set-无法暴露出自身的迭代器（例如-keys-和-values-方法），所以没有任何编程手段来确定-weak-set-中的内容" class="headerlink" title="3.weak set 无法暴露出自身的迭代器（例如 keys() 和 values() 方法），所以没有任何编程手段来确定 weak set 中的内容"></a>3.weak set 无法暴露出自身的迭代器（例如 keys() 和 values() 方法），所以<strong>没有任何编程手段来确定 weak set 中的内容</strong></h5><h5 id="4-weak-set-没有-forEach-方法。"><a href="#4-weak-set-没有-forEach-方法。" class="headerlink" title="4.weak set 没有 forEach() 方法。"></a>4.weak set <strong>没有 forEach() 方法</strong>。</h5><h5 id="5-weak-set-没有-size-属性。"><a href="#5-weak-set-没有-size-属性。" class="headerlink" title="5.weak set 没有 size 属性。"></a>5.weak set <strong>没有 size 属性</strong>。</h5><h5 id="6-最大的区別：weak-set-存储的是弱对象引用"><a href="#6-最大的区別：weak-set-存储的是弱对象引用" class="headerlink" title="6.最大的区別：weak set 存储的是弱对象引用"></a>6.最大的区別：weak set <strong>存储的是弱对象引用</strong></h5><p>一般情况下，如果你只想追踪对象的引用，你应该是用 weak set 而不是 set 。</p>
<h2 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h2><pre><code>为什么需要map？
    set 给了你处理一系列值的新方式，不过若想给这些值添加附加信息则显得捉襟见肘。ECMAScript 6 因此添加了 map 。

与ES5模拟的map有什么区别？
    可以同时使用 5 和 &quot;5&quot; 做为键来存储，因为它们是不同的类型。这和使用对象属性做为值的方法大相径庭，因为对象的属性会被强制转换为字符串类型。</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/Sets-and-Maps-ES6/" data-id="ck43oz3ie001ly0g23zh63plr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git-branch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/git-branch/" class="article-date">
  <time datetime="2019-06-18T06:01:52.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/git-branch/">git分支</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch [branch-name]</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>

<p><img src="git-branch/two-branches.png" alt="git-branch"></p>
<p>可以使用 git branch 查看当前处于哪个分支<br><img src="git-branch/git-branch.png" alt="git-branch"></p>
<p>该命令会在当前所在的提交对象上创建一个指针<br>在 Git 中会有一个名为 HEAD 的指针，指向当前分支<br><img src="git-branch/head-to-master.png" alt="git-branch"></p>
<p>git branch 命令仅仅是创建一个新的分支，并不会自动切换到新分支中，HEAD 指向的是当前分支，而非新创建的分支</p>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout [branch-name]</span><br></pre></td></tr></table></figure>

<p><img src="git-branch/git-branch1.png" alt="git-branch1"><br>此时 HEAD 指针是指向 testing 分支的</p>
<p><img src="git-branch/head-to-testing.png" alt="git-branch"></p>
<p>这样有什么好处呢？<br>HEAD 指向的是点前分支，当你在当前分支做了改变之后，再切换回 master 分支，HEAD 指向的仍旧是原来的 master 旧版本，你在 test 分支上做的任何修改并不会影响 master 分支</p>
<p><img src="git-branch/git-branch2.png" alt="git-branch1"></p>
<p><strong>注意：</strong></p>
<ul>
<li><p>分支切换会改变你工作目录中的文件<br>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
</li>
<li><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p>
</li>
</ul>
<h2 id="git-分支的本质"><a href="#git-分支的本质" class="headerlink" title="git 分支的本质"></a>git 分支的本质</h2><p>Git 的分支，其实本质上仅仅是<strong>指向提交对象的可变指针</strong>。<br>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p><img src="git-branch/commits-and-parents.png" alt="git-branch"></p>
<p>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>。该提交对象会包含一个<strong>指向暂存内容快照的指针</strong>。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的<strong>父对象</strong>的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>暂存操作会为每一个文件计算校验和（SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 <strong>blob 对象</strong>来保存它们），最终将校验和加入到暂存区域等待提交.</p>
<p><img src="git-branch/commit-and-tree.png" alt="git-branch"></p>
<p>当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为<strong>树对象</strong>。 随后，Git 便会创建一个<strong>提交对象</strong>，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<h1 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h1><h2 id="快速新建与切换"><a href="#快速新建与切换" class="headerlink" title="快速新建与切换"></a>快速新建与切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b [branch-name]</span><br></pre></td></tr></table></figure>

<p>上条命令，是以下两个命令的简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch [branch-name]</span><br><span class="line">$ git checkout [branch-name]</span><br></pre></td></tr></table></figure>

<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<p>请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge [branch-name]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>假设你正处于 master 分支，喜事需要解决一个紧急问题，于是新建分支 hotfix</p>
</li>
<li><p>新建紧急处理分支</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br></pre></td></tr></table></figure>

<ul>
<li>修改完成，修复问题后，切回 master 分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<ul>
<li>将 hotfix 分支合并至 master 分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge hotfix</span><br></pre></td></tr></table></figure>

<ul>
<li>这个紧急问题的解决方案发布后，你准备回到之前被打断时的工作中，此时，你要删除 hotfix 分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br></pre></td></tr></table></figure>

<p>现在你可以切换回你正在工作的分支继续你的工作</p>
<p>Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/18/git-branch/" data-id="ck43oz3h3000fy0g2erch2ymq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/14/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2019-06-14T03:15:45.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/">前端缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h1><ul>
<li>http 缓存</li>
<li>浏览器缓存</li>
</ul>
<p><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache.png" alt="cache"></p>
<h2 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求的资源”的副本（缓存），就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>根据是否重新向服务器发送请求分</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
</ul>
</li>
</ul>
<p><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache1.jpg" alt="cache1"></p>
<h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>强制缓存在缓存数据未失效的情况下（即 Cache-Control 的 max-age 没有过期或者 Expires 的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http 状态码为 200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以 Ctrl + F5 一顿操作之后就好了。<br>跟强制缓存相关的 header 头属性有（Pragma/Cache-Control/Expires）</p>
<p><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache2.jpg" alt="cache1"></p>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>当第一次请求时服务器返回的响应头中没有 Cache-Control 和 Expires 或者 Cache-Control 和 Expires 过期还或者它的属性设置为 no-cache 时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回 304 状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回 200 状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的 header 头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现<br><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache3.jpg" alt="cache1"><br>协商缓存的执行流程是这样的：当浏览器第一次向服务器发送请求时，会在响应头中返回协商缓存的头属性：ETag 和 Last-Modified,其中 ETag 返回的是一个 hash 值，Last-Modified 返回的是 GMT 格式的最后修改时间。然后浏览器在第二次发送请求的时候，会在请求头中带上与 ETag 对应的 If-Not-Match，其值就是响应头中返回的 ETag 的值，Last-Modified 对应的 If-Modified-Since。服务器在接收到这两个参数后会做比较，如果返回的是 304 状态码，则说明请求的资源没有修改，浏览器可以直接在缓存中取数据，否则，服务器会直接返回数据。<br><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache4.jpg" alt="cache1"><br><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache5.jpg" alt="cache1"></p>
<p>注意：<br>ETag/If-Not-Match 是在 HTTP/1.1 出现的，主要是解决以下问题：<br>(1)、Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>(2)、如果某些文件被修改了，但是内容并没有任何变化，而 Last-Modified 却改变了，导致文件没法使用缓存<br>(3)、有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>
<!-- ![cache1](前端缓存/cache1.jpg) -->

<ul>
<li><p>根据是否可以被单个或多个用户使用分</p>
<ul>
<li>私有缓存</li>
<li>共享缓存</li>
</ul>
</li>
</ul>
<h5 id="私有缓存（浏览器级缓存）"><a href="#私有缓存（浏览器级缓存）" class="headerlink" title="私有缓存（浏览器级缓存）"></a>私有缓存（浏览器级缓存）</h5><p>私有缓存只能用于单独的用户：Cache-Control: Private</p>
<h5 id="共享缓存（代理级缓存）"><a href="#共享缓存（代理级缓存）" class="headerlink" title="共享缓存（代理级缓存）"></a>共享缓存（代理级缓存）</h5><p>共享缓存可以被多个用户使用: Cache-Control: Public</p>
<h2 id="根据上面的学习可发现使用缓存的好处主要有以下几点："><a href="#根据上面的学习可发现使用缓存的好处主要有以下几点：" class="headerlink" title="根据上面的学习可发现使用缓存的好处主要有以下几点："></a>根据上面的学习可发现使用缓存的好处主要有以下几点：</h2><ol>
<li>减少了冗余的数据传输，节省了网费。</li>
<li>缓解了服务器的压力， 大大提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h2 id="如何使用-HTTP-缓存-？"><a href="#如何使用-HTTP-缓存-？" class="headerlink" title="如何使用 HTTP 缓存 ？"></a>如何使用 HTTP 缓存 ？</h2><p>一般需要缓存的资源有 html 页面和其他静态资源：</p>
<ul>
<li>1、html 页面缓存的设置主要是在<head>标签中嵌入<meta>标签，这种方式只对页面有效，对页面上的资源无效<ul>
<li>1.1、html 页面禁用缓存的设置如下：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 其他主流浏览器识别的标签</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段</span><br></pre></td></tr></table></figure>

<ul>
<li>1.2、html 设置缓存如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;max-age&#x3D;7200&quot; &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 其他主流浏览器识别的标签</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Expires&quot; content&#x3D;&quot;Mon, 20  Aug 2018 23:00:00 GMT&quot; &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 仅有IE浏览器才识别的标签</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、静态资源的缓存一般是在 web 服务器上配置的，常用的 web 服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。</p>
</li>
<li><p>3、不想使用缓存的几种方式：</p>
<ul>
<li>3.1、Ctrl + F5 强制刷新，都会直接向服务器提取数据。</li>
<li>3.2、按 F5 刷新或浏览器的刷新按钮，默认加上 Cache-Control：max-age=0，即会走协商缓存。</li>
<li>3.3、在 IE 浏览器下不想使用缓存的做法：打开 IE，点击工具栏上的工具-&gt;Internet 选项-&gt;常规-&gt;浏览历史记录 设置. 选择“从不”，然后保存。最后点击“删除”把 Internet 临时文件都删掉 （IE 缓存的文件就是 Internet 临时文件）。</li>
<li>3.4、还有就是上面 1、2 中禁用缓存的做法</li>
<li>3.5、对于其他浏览器也都有清除缓存的办法</li>
</ul>
</li>
</ul>
<h2 id="HTTP-缓存的几个注意点"><a href="#HTTP-缓存的几个注意点" class="headerlink" title="HTTP 缓存的几个注意点"></a>HTTP 缓存的几个注意点</h2><ul>
<li><p>1、强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。决解的办法有：在修改后的资源加上随机数,确保不会从缓存中取。<br>例如：<br><a href="http://https://nnyier.github.io/test.css?v=22324432" target="_blank" rel="noopener">http://https://nnyier.github.io/test.css?v=22324432</a><br><a href="http://https://nnyier.github.io/test.2312331.css" target="_blank" rel="noopener">http://https://nnyier.github.io/test.2312331.css</a></p>
</li>
<li><p>2、尽量减少 304 的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。</p>
</li>
<li><p>3、在 Firefox 浏览器下，使用 Cache-Control: no-cache 是不生效的，其识别的是 no-store。这样能达到其他浏览器使用 <strong>Cache-Control: no-cache</strong> 的效果。所以为了兼容 Firefox 浏览器，经常会写成</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache，no-store。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>4、与缓存相关的几个 header 属性有：Vary、Date/Age。</p>
<ul>
<li><p>Vary：<br>vary 本身是“变化”的意思，而在 http 报文中更趋于是“vary from”（与。。。不同）的含义，它表示服务端会以什么基准字段来区分、筛选缓存版本。<br>在服务端有着这么一个地址，如果是 IE 用户则返回针对 IE 开发的内容，否则返回另一个主流浏览器版本的内容。<br>格式：<strong>Vary: User-Agent</strong><br>知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确。</p>
</li>
<li><p>Date/Age：<br>响应报文中的 Date 和 Age 字段：区分其收到的资源是否命中了代理服务器的缓存。<br>Date 理所当然是原服务器发送该资源响应报文的时间（GMT 格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续 F5 刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。<br>Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间（秒），如文件被修改或替换，Age 会重新由 0 开始累计。</p>
</li>
</ul>
</li>
</ul>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache6.jpg" alt="cache1"><br><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache7.jpg" alt="cache1"><br><img src="%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/cache8.jpg" alt="cache1"></p>
<p><a href="https://nnyier.github.io/2019/04/08/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/" target="_blank" rel="noopener">参考：浏览器存储</a></p>
<p><a href="https://mp.weixin.qq.com/s/9QKYhlCr8za3oSCxl_yedA" target="_blank" rel="noopener">参考：http 缓存</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/14/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/" data-id="ck43oz3ih001py0g21wfc6sa1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vue-iView开发过程中碰到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/22/Vue-iView%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2019-05-22T08:35:06.000Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/22/Vue-iView%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Vue+iView开发过程中碰到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多语言问题"><a href="#多语言问题" class="headerlink" title="多语言问题"></a>多语言问题</h1><p>#</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/22/Vue-iView%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ck43oz3gy0007y0g2h60e2ohj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I18n/" rel="tag">I18n</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Project/" rel="tag">Project</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iView/" rel="tag">iView</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I18n/" rel="tag">I18n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Note/" rel="tag">Note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object/" rel="tag">Object</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWA/" rel="tag">PWA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/" rel="tag">Project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Projects/" rel="tag">Projects</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iView/" rel="tag">iView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iconfont/" rel="tag">iconfont</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/localStorage/" rel="tag">localStorage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win10/" rel="tag">win10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1/" rel="tag">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" rel="tag">开发笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ES6/" style="font-size: 12px;">ES6</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/I18n/" style="font-size: 10px;">I18n</a> <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/JavaScript/" style="font-size: 14px;">JavaScript</a> <a href="/tags/Note/" style="font-size: 10px;">Note</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/PWA/" style="font-size: 10px;">PWA</a> <a href="/tags/Project/" style="font-size: 12px;">Project</a> <a href="/tags/Projects/" style="font-size: 10px;">Projects</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Vue/" style="font-size: 18px;">Vue</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/iView/" style="font-size: 12px;">iView</a> <a href="/tags/iconfont/" style="font-size: 10px;">iconfont</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/localStorage/" style="font-size: 10px;">localStorage</a> <a href="/tags/win10/" style="font-size: 10px;">win10</a> <a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">对象</a> <a href="/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">开发笔记</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 16px;">教程</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/12/13/induction/">induction</a>
          </li>
        
          <li>
            <a href="/2019/11/11/%E5%A6%82%E4%BD%95%E5%9C%A8win10%E4%B8%AD%E8%B0%83%E5%87%BAWindows%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/">如何在win10中调出Windows照片查看器</a>
          </li>
        
          <li>
            <a href="/2019/10/12/algorithm/">面试题algorithm</a>
          </li>
        
          <li>
            <a href="/2019/10/10/vue-theme/">Vue+iView 实现主题切换（换肤）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Shengnan Zheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>